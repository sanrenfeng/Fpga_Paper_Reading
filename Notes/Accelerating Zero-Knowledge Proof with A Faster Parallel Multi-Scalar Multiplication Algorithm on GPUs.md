### **Accelerating Zero-Knowledge Proof with A Faster Parallel Multi-Scalar Multiplication Algorithm on GPUs**

在 GPUs 上使用更快的并行多标量乘法算法加速零知识证明

#### 摘要部分

零知识证明是一种关键的密码原语。它最实用的类型，称为零知识简洁非交互式知识论证( zkSNARK ），已经部署在各种隐私保护应用程序中，如加密货币和可验证机器学习。不幸的是，像 Groth16这样的 zkSNARK 在其证明生成步骤上有很高的开销，它包括几个耗时的操作，包括大规模矩阵向量乘法（ MUL ）、数论变换（ NTT ）和多标量乘法（ MSM ）。因此，本文提出了 cuZK ，一种高效的 zkSNARK GPU实现，采用以下三种技术来实现高性能。

- 首先，我们提出了一种新的并行 MSM 算法。与著名的串行MSM算法Pippenger 算法相比，该MSM算法获得了近乎完美的线性加速比。
- 其次，我们并行化了 MUL 操作。结合我们自己设计的 MSM 方案和经过充分研究的 NTT 方案，cuZK 在证明生成步骤中实现了所有操作的并行化。
- 第三，cuZK 通过1 ) 减少冗余数据传输 2 ) 重叠数据传输和设备计算，降低了CPU - GPU数据传输带来的延迟开销。

评估结果表明，该论文 MSM 模块与最先进的 GPU 实现相比提供了超过 2.08 × (最高可达 2.94 ×)的加速比。cuZK 在标准测试集上获得了超过 2.65 × (高达 4.86 ×)的加速比，在 GPU 加速的加密货币应用程序文件币上获得了超过 2.18 ×的加速比。



#### Introduction 部分

​	零知识证明（ZKP）是一种密码原语，它允许证明者生成一个证明 π，以说服验证者计算 y = f（x，w）是用公共输入 x 和证明者的秘密输入 w 正确计算的。此外，证明 π 没有泄露任何关于秘密输入 w 的信息。近年来，由于一种名为zkSNARK 的先进 ZKP 类型的出现，ZKP 引起了学术界和工业界的广泛关注，它代表零知识简洁非交互式知识论证。与其他传统的 ZKPs 相比，zkSNARK 具有更简洁明了的证明 π。例如，由 Groth 提出的 zkSNARK 协议中生成的证明只有数百个字节，并且可以在几毫秒内非常快速地进行验证。因此，zkSNARK 被广泛认为是最实用的 ZKP，并已被应用于许多私有保护应用中比如电子投票、可验证的数据库外包、加密货币和可验证的机器学习。

​	然而，仍然存在一个限制了 zkSNARK 的进一步部署的瓶颈。目前，最先进的zkSNARKs 在其证明生成步骤上有很高的开销。[Gro16] 中的证明程序需要执行各种耗时的操作来生成证明 π。这些耗时的操作包括大尺度矩阵向量乘法（MUL）、数字理论变换（NTT）和椭圆曲线上的多标量乘法（MSM），**导致函数f的总体证明生成时间比计算该函数的时间要长得多，有时甚至长达数千倍。**

​	减少证明生成时间的解决方案之一是在某些硬件上并行化这项任务。GPU 是一种多核计算平台，支持数千个线程的并发执行。它们已被用于加速各种各样的计算模块，如深度学习、密码学和图形。zkSNARK 也有几种现有的 GPU 设计。例如，Mina 宣布了一项挑战，即加速使用 GPU（10万美元）。这个挑战的最终加速结果在 [Min19] 中都是开源的。另一个 GPU 实现 Bellperson 是从基于 CPU 的版本 Bellman 改进而来的。Bellperson 已经被部署在一个著名的去中心化加密货币网络 Filecoin。图1显示了它们在 zkSNARK 操作上的执行时间分解，包括MUL 、NTT 、MSM 和 GPU-CPU 数据传输。显然，这些 GPU 实现的整体性能在很大程度上取决于上述四种操作的效率。特别是，MSM是最耗时的操作，占总运行时间的70%以上。

![image-20230915144902608](C:\Users\lijiayong\AppData\Roaming\Typora\typora-user-images\image-20230915144902608.png)

​		然而，在现有的 GPU 实现中执行的这些操作有以下弱点。	

1. MSM：这些 GPU 实现中用于 MSM 计算的并行算法都是从低并行度设置中使用的并行算法简单修改而来。然而，这些并行算法很难适用于同时运行上千个线程的情况，表现为随着并行度的增加，加速比的提升不尽如人意；

  2. MUL：我们注意到现有的 GPU 设计低估了 MUL 操作的计算成本。它们选择在 CPU 上连续执行 MUL 操作，而不是在 GPU 上并行执行。实际上，串行运行 MUL 的缓慢方式会严重阻碍整体性能；

  3. 数据传输：这些 GPU 实现也在 CPU-GPU 数据传输上浪费了太多的时间，这实际上可以通过减少冗余数据传输和数据传输与设备计算的重叠来减轻。值得注意的是，Mina [ Min19 ]在串行执行 NTT 时消耗了大量的时间，但不必认为 NTT 是一个弱点。许多高效的并行 NTT 方案已经被广泛研究。 因此，我们可以很容易地将[ Min19 ]中使用的串行 NTT 方案替换成并行 NTT 方案。例如，文献[ Bel19 ]中使用的并行 NTT 方案来自文献[ Bai10 ]。 

#### 论文贡献

在本文中，我们提供了一个有效的 GPU 对 zkSNARK 的实现，通过解决上述其他先进作品的弱点。所提出的技术可以在现代 GP U架构上实现高性能。本文的贡献总结如下：

1. 我们提出了一种新的并行 MSM 算法。这种 MSM 算法不同于其他普通并行方法，简单地将大 MSM 计算分解为多个小并行方法。我们将 MSM 的所有计算单位作为一个整体来处理，并将 MSM 的所有元素存储在一个稀疏矩阵中。这使我们能够将著名的串行 Pippenger 算法中使用的主要操作转换为一系列基本的稀疏矩阵操作，包括稀疏矩阵转置和稀疏矩阵向量乘法。接下来，我们利用研究充分的并行稀疏矩阵算法中使用的技术来加速 MSM 的计算。因此，我们的并行 MSM 算法不仅很好地适应了 GPU 提供的高并行性，而且比Pippenger 算法实现了几乎完美的线性加速，其中完美的线性加速意味着并行加速比等于执行线程的数量。我们首先证明了 MSM 的计算可以在稀疏矩阵运算的帮助下并行化，并且我们相信这种使用稀疏矩阵的想法将激励许多其他的并行化方法。
2. 我们提出了 cuZK ，一个有效的 GPU zkSNARK 实现。我们进行了三种优化来帮助 cuZK 实现高性能。首先，我们实现了我们新的并行 MSM 算法，并将其部署在 cuZK 的 MSM 模块中。这部分主导了 zkSNARK 的总成本，因此极大地影响了整体性能的改进。其次，我们注意到 MUL 操作的矩阵非常大，但很稀疏。因此，我们用稀疏矩阵格式来表示它，这允许我们将整个矩阵存储在GPU上，并在稀疏矩阵上使用并行格式进行MUL计算。此外，cuZK 结合我们自己设计的 MSM 并行方案和经过研究充分的NTT并行方案，cuZK 确实实现了 zkSNARK 中所有耗时操作的并行化。第三，cuZK 通过重叠数据传输和使用多流技术的设备计算，减少了 CPU-GPU 数据传输造成的延迟开销。此外，不需要冗余的数据传输，因为当我们在 GPU 上执行所有的 zkSNARK 操作时，它会被自动消除。
3. 我们设计了一系列的 cuZK 评价方案。评估结果表明，与最先进的 GPU 实现相比，我们的MSM模块提供了超过 2.08×（高达2.94×）的加速。cuZK 的整体性能在标准基准测试上实现了超过 2.65×（高达4.86×）的加速，在 GPU 加速的加密货币应用程序硅币上实现了 2.18×的加速。

　

#### 相关工作

​	最近，许多以前的工作已经在某些硬件上实现了高性能的 zkSNARK ，包括 GPUs、ASICs 和 CPU集群。

​	PipeZK 是一个为 zkSNARK 提供流水线 ASIC 设计的工作。虽然这项工作在 zkSNARK 上对匿名支付等小规模应用上具有极好的效率，但由于大规模应用，其性能显著下降由于片上 ASIC 的存储限制。

​	DIZK 利用Apache Spark 将证明生成步骤分发到 CPU 集群。然而，部署 CPU 集群的成本比使用 GPU 卡和 ASIC芯片要高得多，这阻碍了 DIZK 的广泛部署。	Bellpermon 和Mina 是 zkSNARK 的高效 GPU 实现。然而，如前所述，它们的 MSM 和 MUL 模块并没有完全释放GPU的潜力，它们也在CPU-GPU数据传输上浪费了太多的时间。

​	MSM 是 zkSNARK 中最耗时的操作。因此，提高 MSM 对 GPUs、FPGAs 和ARM CPUs的效率的研究较为显著。特别是 ZPrize 竞赛的获奖作品是与本文同时进行的作品。它们在使用随机采样标量的 MSM 计算上取得了优异的性能。它们出色的性能得益于核心技术，即利用基数排序来处理 MSM 中使用的标量，这实际上可以看作是我们 的MSM 算法中使用的稀疏矩阵转置的具体方案，如第4.1节所示。但即便如此，这两种方案都不能直接部署在 zkSNARK 上，其中MSM中使用的标量依赖于证明函数f，而不是简单的随机分布的。

#### 准备工作

##### Groth zkSNARK 协议

​	我们的工作提供了一个由 Groth 提供的 zkSNARK 协议的 GPU 实现。我们选择Groth 的协议是因为它是最有效和最实用的 zkSNARK 协议之一，并且它已经被各种私有保护应用程序所采用，包括加密货币、智能合同和可验证的机器学习。在这里，我们还需要提到的是，我们的技术可以用于类似的 zkSNARK 协议，特别是对于需要执行多标量乘法操作的协议。

​	Groth 的协议工作方式和所有的 zkSNARKs 一样。它允许一个证明器生成一个证明 π，以说服验证者用一个公共输入 x 和一个证明器的秘密输入 w 来计算 y=f（x，w）是正确的。此外，它的证明 π 只有数百个字节，并且可以在几毫秒内进行验证。格罗斯协议的工作流程如图所示。它包括三个过程：**预处理、验证和验证。**

![image-20230915154000187](C:\Users\lijiayong\AppData\Roaming\Typora\typora-user-images\image-20230915154000187.png)

​		预处理过程由可信赖第三方执行。它首先将一个函数 f 编译到 1级约束系统（R1CS）的实例。图2的右上方显示了编译过程的一个简单示例。简而言之，函数 f 被分解为多个约束，每个约束都可以用三个向量表示。这些约束向量最终形成了三个矩阵，它们被称为 R1CS 实例。约束的数量通常被认为是 R1CS 实例的规模。

​		接下来，第三方受信任方使用这个 R1CS 实例及其秘密随机数来生成证明者密钥 pk和一个验证者密钥 vk 。这两个键都是公开的。也就是说，任何人都可以用证明者密钥 pk 执行 Prove 过程生成一个证明 π，任何人都可以用证明 π 和验证者密钥 vk 执行 Verify 过程。限制条件是只有拥有满足y = f( x , w)的秘密输入 w的证明者产生的证明 π 才能使验证者接受。此外，证明π没有泄露关于秘密输入 w 的信息，除拥有者外，任何人都不能得到秘密输入 w 的值。

​		预处理过程和校验过程对轻量级计算成本进行了摊销。对于预处理过程，函数 f 的两个键 pk 和 vk 是无限可重用的，这样它的计算成本可以在每次使用两个键时分摊。对于 Verify 过程，它只需要验证者执行三个双线性对运算，如 Weil 对和 Tate 对。这些配对操作是将两个数学空间映射到第三个空间的函数，可以在短短几毫秒内使用 Miller 算法计算。Prove 过程 是唯一的高费用过程。如图 2 右下方所示，它需要证明者执行各种耗时的操作，包括 MUL、NTT 和 MSM 。这导致 Prove 过程成为限制 zkSNAKR 进一步部署的瓶颈。我们的工作重点是用GPU加速这一过程。

#### 多标量乘法(MSM)

多标量乘法（MSM）是 zkSNARK 中最耗时的操作，占用了总运行时的70%以上。它的定义由 $Q = \sum_{i=1}^n k_i P_i $ 给出，其中 n 是 MSM 的尺度，$k_i$是一个 λ-bits标量，Pi是一个椭圆曲线（EC）点，其中 kiPi 表示 ki 和 Pi 的点标量乘法。在形式上，椭圆曲线是由 EC 点组成的光滑、射影的代数曲线。这些点包括这些满足一个特定的数学方程的集合，如$y^2 = x^3 + ax + b$​，点无穷，表示为O。无穷远处的点作为所有 EC点 构成的阿贝尔群中的单位元，其基本操作称为点加法( PADD )。点倍增( PDBL )是PADD的一种特殊情况，其结果等于在两个相同的点上执行一个PADD操作。标量 k 和 EC 点 P的 PMULT 是椭圆曲线算法中另一种常用的运算。它被定义为 k 次 self-PADD ，记为 kP = P + P + .. + P .我们可以用double - and - add方法来计算
